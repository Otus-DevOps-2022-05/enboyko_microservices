# enboyko_microservices
enboyko microservices repository

---
# HOMEWORK #12 and #13 (2in1):

1. Создал репозиторий **docker-2**
2. Установил **docker** и **docker-tools**
3. Попрактиковал и изучил базовые команды **docker**
4. Устновил и настроил **docker-machine**
5. Создал новый инстанс в **YC** из стандартного образа в **image-family** **ubuntu-1804-lts**
6. В вышеуказанном инстансе создал *docker-host* с помощью **docker-machine**
7. Создал структуру репозитория **docker-monolith**, из **Dockerfile** собрал образ, на основании которого затем запустил контейнер и проверил работу приложения.
8. Аутентифицировался на **docker-hub** (ранее был зарегистрирован) и попрактиковался в работе с ним.
9. Удалил инстанс в Yandex Cloud

#### Задание со ⭐

1. В **docker-1.log** сравнил вывод команд:
    `docker inspect <u_container_id>`
    и
    `docker inspect <u_image_id>`

---
# HOMEWORK #14:

1. Установил и применял в работе **linter** - **hadolint**
2. Разбил приложение на несколько компонентов - создал новую структуру микросервисного приложения.
Для каждого сервиса - **post-py**, **comment** и **ui** - создал свой **Dockerfile**. Собрал, запустил и проверил приложение.
3. Оптимизировал образ для сервиса **ui** - таким образом, уменьшил его размер. Пересобрал, перезапустил и проверил приложение.
4. Создал Docker volume, подключил его к контейнеру с **MongoDB**. Пересобрал, перезапустил и проверил приложение.

---
# HOMEWORK #15:

### 1. Работа с сетями в Docker
1. Разобрался с работой сетей в **Docker** - с такими **network driver**'ами, как **none**, **host** и **bridge**
В частности, создал сети **back_net** и **front_net** - две **bridge**-сети. При этом сервис ui не имел напрямую доступа к базе данных.
2. Изучил, как выглядит сетевой стек Linux при топологии **bridge network driver**
Во всех рассмотренных случаях запустил приложение и проверил его работу.

### 2. Использование docker-compose
1. Установил **docker-compose** на локальную машину.
2. Собрал образы приложения **reddit** с помощью **docker-compose**
3. Запустил приложение **reddit** с помощью **docker-compose**
4. Оптимизировал конфигурацию **docker-compose**, добавив интерполяцию (подстановку) переменных окружения в **docker-compose.yml**. При этом сами переменные окружения инициализировал и объявил в файле для параметризации **.env**

#### Ответ на вопросы из задания в методическом указании:
1. Базовое имя проекта формируется из имени корневого каталога для файла **docker-compose.yml** ; в нашем случае, это - **src**.
2. Имя проекта можно задать:
- с помощью команды `docker-compose -p [имя_проекта] up -d`
- с помощью инициализации и объявления переменной окружения **COMPOSE_PROJECT_NAME** в файле параметризации типа **.env***

---
# HOMEWORK #16:

### 1. Подготовил инсталляцию Gitlab CI
1. Создал в **Yandex.Cloud** новую виртуальную машину (инстанс) с помощью **Yandex.Cloud CLI**.
2. В вышеуказанном инстансе создал *docker-host* с помощью **docker-machine**.
3. На инстансе создал директории под **data volumes**.
4. В директории **/srv/gitlab** создал файл **docker-compose.yml**.
5. Запустил контейнер и проверил корректность отображения **GitLab** в браузере по адресу инстанса в **Yandex.Cloud**.
6. На стартовой странице указал логин и пароль для административного аккаунта (**root**).
7. Отключил регистрацию в **GitLab**.
8. Создал группу и проект.
9. Добавил удаленный репозиторий (в **GitLab**) в конфиг **Git**’а.

### 2. Описал для приложения этапы пайплайна
1. Определил пайплайн для **GitLab** в файле **.gitlab-ci.yml**.
2. Запушил изменения в удаленный репозиторий.
3. Проверил статус пайплайна - он находился в статусе **pending** (или **stuck**).
4. В настройках проекта получил токен для регистрации будущего раннера.
5. Добавил раннер.
6. Зарегистрировал раннер.
7. Проверил раннер - увидел его в настройках.
8. Проверил пайплайн - он запустился после добавления раннера.

### 3. Подготовил репозиторий с кодом приложения
1. Добавил исходный код **reddit** в репозиторий.
2. Создал файл **simpletest.rb** с тестами в директории **reddit**.
3. Добавил библиотеку **rack-test** для тестирования в файл **reddit/Gemfile**.
4. Запушил код в **GitLab** и убедился, что теперь **test_unit_job** гоняет тесты.

### 4. Определил окружения
1. Добавил окружения **dev**, **staging** и **production** в **.gitlab-ci.yml**.
2. Проверил наличие новых окружений.
3. Добавил в описание пайплайна директиву **only**, которая не позволит выкатить на **staging** и **production** код, не помеченный с помощью тэга в **git**.
4. Добавил задачу с динамическими окружениями в **.gitlab-ci.yml**.
5. Проверил создание динамических окружений.

---
# HOMEWORK #17:

### 1. ЗАПОЛНЮ ПОЗЖЕ

docker push jaxowner/ui
docker push jaxowner/comment
docker push jaxowner/post
docker push jaxowner/prometheus
